# -*- coding: utf-8 -*-
"""Untitled71.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M-eQG-rRjcPjNlnJb-87zXC2UAgGAK_S
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import seaborn as sns

google=pd.read_csv("/content/googleplaystore.csv.zip")
google.head(2)

google.shape

google.tail()

google.info()

google['Rating']=google['Rating'].fillna(google['Rating'].mean(),inpace=True)

google['Rating'].mean()

google

google.info()

google.corr()

sns.heatmap(google.corr())

for x in google.describe(include='number').columns:
  print(x)
  print(google[x].unique())

for x in google.describe(include='number').columns:
  print(x)
  print(google[x].nunique())

for x in google.describe(exclude='number').columns:
  print(x)
  print(google[x].nunique())

for x in google.describe(exclude='number').columns:
  print(x)
  print(google[x].unique())

google.columns

google.index

google[google['Type'].isin(['Free','Paid'])]

google['Type'].value_counts().plot(kind='bar')

google.describe(include='all')

"""7. Find Average App Rating"""

google['Rating'].mean()

"""find average and max and min app rating"""

google['Rating'].agg(['mean','max','min']).astype('int')

google.columns

"""9. Which Category Getting The Highest Average Rating?"""

rating1=google.groupby('Category')['Rating'].mean().reset_index(name="average rating")
rating1

plt.figure(figsize=(15,6))
plt.bar(rating1['Category'],rating1['average rating'])
plt.xticks(rotation=60,size=6)
plt.xlabel("category",size=13,loc='center')
plt.ylabel("average rating",size=16,loc='center')
plt.title("average rating vs category in paly store ",loc='center',size=20)
plt.show()

"""how many of person rating is 5"""

google[google['Rating']==5]

percentage_of_5_ratings = (len(google[google['Rating'] == 5]) * 100) / google.shape[0]

"""here 5 rating people only 2%"""

percentage_of_5_ratings = (len(google[google['Rating'] == 5] )* 100) / google.shape[0]
percentage_of_5_ratings

"""rating is 4.19,4.40 more number of people resopnding"""

google['Rating'].value_counts(normalize=True).head(3)

google['Rating'].value_counts().head(3)

google['Rating'].value_counts().plot(kind='bar',figsize=(20,6))

"""11. Find Average Value of Reviews"""

google[google['Reviews']=="3.0M"]

google['Reviews']=google['Reviews'].replace('3.0M',3.0).astype('float')

google['Reviews'].dtype

"""find the average reviews"""

google['Reviews'].mean()

google['Size'].value_counts()

google['Size'].max()

google[google['Size']=='Varies with device']

google

""". Which App Has Maximum Reviews?"""

google[google['Reviews'].max()==google['Reviews']][['App','Size','Type','Price','Last Updated']]





""". Which App Has Minimum Reviews?"""

google

"""14. Display Top 5 Apps Having Highest Reviews"""

google.sort_values(by='Reviews',ascending=False)['App'].head(5)

google1=google.groupby('App')['Reviews'].mean().reset_index().sort_values(by='Reviews',ascending=False).head(10).set_index('App')
google1

google1.plot(kind='barh')
plt.xlabel("number of reviews",size=13)
plt.ylabel("TYPES OF APP")
plt.title("number of reviews vs types of app",size=16,loc='center')

"""15. Find Average Rating of Free and Paid Apps"""

google.groupby('Type')['Rating'].agg(['mean','max','min','sum'])

"""16. Display Top 5 Apps Having Maximum Installs
data.head(1)
"""

google.sort_values(by='Installs',ascending= False)['App'].head(5)



google

google['Installs_1']=google['Installs'].str.replace(',','')

google['installs_2']=google['Installs_1'].str.replace('+','')

google.head(2)

"""Display Top 5 Apps Having Maximum Installs data.head(1)"""

google.sort_values(by='installs_2',ascending=False)['App']

google['installs_2'].value_counts()

google[google['installs_2']=='Free']

google['installs_2']=google['installs_2'].str.replace('free','0')

google['installs_2']=google['installs_2'].astype('int')

google.sort_values(by='installs_2',ascending=False)['App'].head(5)

google['Price'].value_counts().head(90)

google[google['Price']=='Everyone']

google=google[google['Price']!='Everyone']
google['Price']=google['Price'].str.replace('.','')
google['Price']=google['Price'].str.replace('$','')
google['Price'].astype(int)

google['Price'].value_counts()

"""Display Top 5 Apps Having Maximum Installs data.head(1)"""

google.groupby('App')['Price'].min().reset_index().sort_values('Price',ascending=False).shape

google.shape

google.groupby('App')['Price'].min().reset_index().sort_values('Price',ascending=False)

google[['Price','Category']]

google['Size'].value_counts()

google1=google[google['Size']!="Varies with device"]
google1['Size']=google1['Size'].str.replace('.','')
google1['Size']=google1['Size'].str.replace('M','100000')
google1['Size']=google1['Size'].str.replace('K','1000')
google1['Size']=google1['Size'].str.replace('201K','1000')

google=google[google['Size']!="Varies with device"]

google["Size"]=google['Size'].str.replace('M','000000')
google["Size"]=google['Size'].str.replace('k','000')
google['Size']=google['Size'].astype(int)

google["Installs"]=google['Installs'].str.replace(',','')
google["Installs"]=google['Installs'].str.replace('+','')
google['Installs']=google['Installs'].astype(int)

google.info()

google[['Price','Size']]

google['Content Rating'].value_counts()

"""find the avg content rating of the size downloads of each"""

google2=google.groupby('Content Rating')['Size'].mean().reset_index().sort_values(by='Size',ascending=True)
google2

sns.barplot(data=google2,x=google2['Content Rating'],y=google2['Size'])
plt.xticks(rotation=90,size=10)

plt.xlabel("content rating",size=13)
plt.xlabel("size",size=13)
plt.title("content rating vs size",size=13)
plt.show()

"""min aggreatate function based on the content ratings

more number of size adults only 41000000
"""



google3=google.groupby('Content Rating')['Size'].min().reset_index().sort_values(by='Size',ascending=True)
google3

sns.barplot(data=google2,x=google2['Content Rating'],y=google2['Size'])
plt.xticks(rotation=45,size=10)
plt.xlabel("content rating",size=13)
plt.xlabel("size",size=13)
plt.title("content rating vs size",size=13)
plt.show()

"""insights from the min and avg content rating of the size

here number of the adults only app size more
"""

sns.barplot(data=google2,x=google2['Content Rating'],y=google2['Size'])
plt.xticks(rotation=90,size=10)

google['Genres'].value_counts().plot(kind='barh',figsize=(10,35))

google['Last Updated']=pd.to_datetime(google['Last Updated'])
google['month']=google['Last Updated'].dt.month
google['year']=google['Last Updated'].dt.year
google['nameoftheweek']=google['Last Updated'].dt.dayofweek

"""here the year will be increases and also ratings increasings


in 2010 less number ratings
in 2018 more number rating like avg,max,sum
"""

google.groupby(['year'])['Rating'].agg(['mean','min','max','sum'])

"""important ones fhe future"""

df=df[df['Content Rating']!="Adults only 18+"]
df=df[df['Content Rating']!="Unrated"]
df["Content Rating"]=df["Content Rating"].map({"Everyone":0,"Teen":1,"Mature 17+":2,"Everyone 10+":3})
#We replace the values in Content Rating with 0, 1, 2 and 3.
df['Content Rating']=df['Content Rating'].astype(int)

google.groupby(['nameoftheweek'])['Rating'].agg(['mean','min','max','sum'])

google['Current Ver'].value_counts().head(100).plot(kind='bar',figsize=(15,5))

google['Price']=google['Price'].replace('$','')
google['Price']=google['Price'].replace('Everyone','0')
google['Price'].astype('int')
print(f"Datatype of ['Price'] column is now : {google['Price'].dtypes}")

google.info()

google['Price']=google['Price'].apply(lambda x:x.strip("$"))
google['Price']=google['Price'].apply(lambda x:x.replace("everyone","0"))
google['Price'].astype('int')
google.info()

google['Price'] =google['Price'].apply(lambda x : x.replace('$',''))
google['Price'] = google['Price'].apply(lambda x : x.replace('Everyone', '0'))
google['Price'] = google['Price'].astype('float')
print(f"Datatype of ['Price'] column is now : {google['Price'].dtypes}")

google.nlargest(10,'Rating')[['Reviews','Price']]

google.nlargest(10,'Price')[['Price','App']]

google.nsmallest(10,'Price')[['Price','month','year']]

google3=google.groupby(['nameoftheweek','Genres']).get_group((2,'Art & Design'))

google

google2.mean()

google[google['Type']=='Free']

google['Type'].value_counts()

google.info()

google.groupby('Category')['Price'].max().plot(kind='bar')

"""single column and multiple column to apply to aggregate functions"""

google.groupby('Category')[['Price','Size']].agg({"Price":['mean','max','sum'],"Size":["sum","min","max","count"]})

google.groupby('Category')[['Price','Size']].describe()

filtered_data = google.groupby('Price').filter(lambda x: (x['Price'] > 10000).any())
filtered_data

"""here only 12 months when have to groupby"""

google.groupby('month').ngroups

"""here only 9 year when have to groupby"""



google.groupby('year').ngroups

google.groupby('Content Rating').size()

google.groupby('Content Rating').count()

google.groupby('month').last()

google.groupby('year').first()

google.groupby('year').first()

google.groupby("month").first()

"""
0s
google.apply('sum')
output
<ipython-input-513-28ef876b3152>:1: FutureWarning: The default value of numeric_only in DataFrame.sum is deprecated. In a future version, it will default to False. In addition, specifying 'numeric_only=None' is deprecated. Select only valid columns or specify the value of numeric_only to silence this warning.
  google.apply('sum')"""

google.apply('sum')

"""apply

df['total'].agg(['mean','min')

here single column to apply aggreate function same way below just will provide google['Size'].apply(['mean','min')] it gives same output

single variable without groupby
"""

google['Size'].agg(['mean','min'])

google['Size'].apply(['mean','min'])

google['Price'].apply(['mean','min','max'])

"""apply multiple colums allowing"""

google[['Price','Size']].apply(['mean','max'])

google[['Price','Size']].apply({"Price":['mean','min','max','sum','count'],"Size":["mean","min","sum"]}).fillna(1)

"""
You will get error


df.transform('sqrt')"""

google.transform('sqrt')

"""There are 3 main differences when using apply() and transform():


1. transform() can take a function, a string function, a list of functions, and a dict. However, apply() is only allowed a function.


2. transform() cannot produce aggregated results


3. apply() works with multiple Series at a time. But, transform() is only allowed to work with a single Series at a time.
"""

google['Size'].apply('sum')

"""transform we will not work for the min,max ,sum,count,mean"""

google['Size'].transform('square')

google['Size'].transform('square')

"""here other than aggretate function gives output gives same as input function rows or length then we google.shape 9145 and size in transform create shape is 9145"""

google.shape

google['Size'].apply('square')

google['Size'].transform('square')

sales=pd.read_csv("/content/supermarket_sales.csv")
sales

sales['Quantity'].transform('square')

"""whenever you wont use the combine aggretation,square,median



"""

sales['Quantity'].apply(['mean','square'])

sales['Qunatity']

sales['Quantity'].apply(['mean','sum'])

sales['Quantity'].transform([np.square,np.exp])

sales

"""groupby function"""

sales.groupby('Gender')['Quantity'].apply('sum')

"""transform groupby

output values gives the same as the input length

whenever you willl be working with two variables aggregation working fine
"""

sales.groupby('Gender')['Quantity'].transform('sum')

sales.groupby('City')['Quantity'].apply('sum')

"""the output values gives the same length of input values

"""

sales.groupby('City')['Quantity'].transform('sum')

"""multiple aggregate  does not working for the apply,transform
we just move only single agg
"""

sales.groupby('City')['Quantity'].apply(['sum','mean'])

sales.groupby('City')['Quantity'].transform(['sum','mean'])

sales.groupby('Product line')['Total'].apply('max')

"""the output values gives the same length of input values"""

sales.groupby('Product line')['Total'].transform('max')

sales.groupby('Product line')['Total'].apply('median')

"""the output values gives the same length of input values"""

sales.groupby('Product line')['Total'].transform('median')

sales.groupby('Product line')['Total'].apply('mean')

sales.groupby('Product line')['Total'].transform('mean')

sales.groupby('Product line')['Total'].apply('square')

sales.groupby('Product line')['Total'].transform('square')

"""group by function two varaible

1.apply can be work the aggregation opeartion whne to use two variables


1.transform can be work aggregation operation when to use two variables
"""

sales['total_payment']=sales.groupby('Payment')['Total'].transform("sum")
sales

sales['total_payment_percentage']=sales['Total']/sales['total_payment']
sales['total_payment_percentage']=sales['total_payment_percentage']*1000

#whneveryou have cat values that time us specify column name df['A].apply(sum)

df1 = pd.DataFrame({'A': [1,2,3], 'B': [10,20,30],'name' :['jagan','nan','VenKY']})
df1

df2=pd.DataFrame({'A': [1,2,3], 'B': [10,20,30]})
df2

def sum(x):
  return x+10
df2.apply(sum)

def sum(x):
  return x+10
df2.transform(sum)

df2.apply(lambda x:x+10)

df2.transform(lambda x:x+20)

"""
3 main differences

transform() can take a function, a string function, a list of functions, and a dict. However, apply() is only allowed a function.

transform() cannot produce aggregated results

apply() works with multiple Series at a time. However, transform() is only allowed to work with a single Series at a time."""

df3 = pd.DataFrame({'A': [1,2,3], 'B': [10,20,30] })
df3

"""create string function for transform"""

df3.transform('square')

"""create list function transform

when you have specify np.sqrt dont use double quotes between variables
"""

df3.transform([np.sqrt,np.exp])

"""create function for the dict format"""

df3.transform({
    'A':np.sqrt,
    'B':np.exp
})

def sum(x):
 return x.sum()

df3.apply(sum)

"""2. transform() cannot produce aggregated results"""

def sum(x):
 return x.sum()

df3.Transform(sum)

## but getting error with transform()
df['A'].transform(lambda x:x.sum())

"""3. apply() works with multiple Series at a time. However, transform() is only allowed to work with a single Series at a time."""

def subtract_two(x):
    return x['B'] - x['A']
df3.apply(subtract_two,axis=1)

def subtract_two(x):
    return x['B'] - x['A']
df3.transform(subtract_two,axis=1)

df3.apply(lambda x:x['B']-x['A'],axis=1)

df3.transform(lambda x:x['B']-x['A'],axis=1)

df = pd.DataFrame({
    'key': ['a','b','c'] * 3,
    'A': np.arange(9),
    'B': [1,2,3] * 3,
})
df

def sum(x):
  return x.sum()
df.groupby('key')['A'].apply(sum)

def sum(x):
  return x.sum()
df.groupby('key')['A'].transform(sum)

"""myself"""

df.groupby('key')['A'].apply(lambda x:x.sum())

df.groupby('key')['A'].transform(lambda x:x.sum())

"""2. apply() works with multiple Series at a time. However, transform()
is only allowed to work with a single Series at a time
"""

def subtract_two(x):
    return x['B'] - x['A']
df.groupby('key').apply(subtract_two)
#output like df.groupby('columns).mean() or max().or min() like this  just we are using subract_two

df.groupby('key').transform(subtract_two)